# Chapter 5. 메모리 관리

## 메모리 통계 정보

### free

free 명령어로 메모리에 대한 정보를 알 수 있다. (단위 : KiB)

```sh
$ free
              total        used        free      shared  buff/cache   available
Mem:        7729028     1552460     4177240      536648     1999328     5375580
스왑:       2097148           0     2097148
```

- total : 시스템의 전체 메모리 용량

- free : 표기 상 이용하지 않는 메모리 (available - buff)

- buff/cache : 버퍼 캐시, 페이지 캐시가 이용하는 메모리. free 필드의 메모리가 부족하면 커널이 buff/cache 메모리를 해제하고 할당해준다.

- available : 실질적으로 사용할 수 있는 메모리. *free + buff/cache + 다른 커널 내의 해제할 수 있는 메모리* 를 의미한다.

### sar -r

**sar -r** 명령어를 통해 메모리에 관련된 통계 정보를 얻을 수 있다.

```sh
$ sar -r 1 1 # 1초 간격(2번째 파라미터)으로 1번만(3번째 파라미터)
Linux 5.13.13-surface (ubun2-Surface-Pro-7) 	2021년 09월 16일 	_x86_64_(8 CPU)

00시 44분 33초 kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
00시 44분 34초   4225432   5460160   1397816     18.09     67080   1869944   6410488     65.24    722640   2019192       152
...
```

free 결과와의 비교

- free 명령어 결과의 free 필드 : kbmemfree

- buff/cache 필드 : kbbuffers + kbcached

---

## 메모리 부족

메모리 사용량이 증가하면 비어 있는 메모리(free 필드)가 줄어들고, 커널은 해제 가능한 메모리 영역(buff/cache + 다른 커널에서 해제 가능한 영역)을 해제한다.

메모리 사용량이 감당할 수 없을 정도로 계속해서 증가하면 시스템은 메모리 부족 상태<sub>OOM, Out Of Memory</sub>가 된다.

- OOM Killer : 메모리 관리 시스템이 적절한 프로세스를 선택하여 강제 종료(kill) 하여 메모리를 확보하는 기능

- OOM Killer는 어떤 프로세스가 강제 종료될 지 알 수 없다. 내부적으로는 우선순위나 사용한지 오래되었다거나 하는 알고리즘을 통해 선정할 것이다. 

- 서버 컴퓨터에서 프로세스가 강제 종료되어 문제가 발생할 경우 조치가 더 힘들기 때문에, sysctl의 `vm.panic_on_oom` 파라미터의 기본 값을 1로 변경하여 메모리 부족 시 시스템 자체를 강제 종료하는 경우도 있다고 한다.

---

## 단순 메모리 할당

메모리 할당이 필요한 상황은 주로 프로세스를 생성하거나, 동적 메모리를 할당하는 경우이다. 프로세스를 생성하는 경우는 3장에서와 같이 fork(), execve() 등의 함수를 이용하는 경우이다.

메모리 할당은 단순히 물리 메모리에 할당하는 방식과 가상 메모리를 사용하는 방식이 있는데, 단순 메모리 할당 방식은 문제점이 있다.

### 동적 메모리 할당 과정

프로세스에서 동적으로 메모리가 필요한 경우, 프로세스는 커널에 메모리 확보용 시스템 콜을 호출한다. 커널은 필요한 사이즈를 메모리 영역에서 확보하고, 해당 영역의 시작 주소값을 반환한다. 실제 메모리 할당 방식은 가상 메모리를 통해 이루어진다. 단순 메모리 할당 방식을 사용하면 다음의 문제점들이 존재한다.

- 메모리 단편화

- 다른 프로세스의 메모리에 접근 가능

- 여러 프로세스 실행 시 문제

### 메모리 단편화<sub>memory fragmentation</sub>

메모리의 획득, 해제를 반복할 경우 메모리에 빈 공간이 여러 군데에 쪼개져있는 상태로 지속되고, 이 때문에 메모리가 충분함에도 큰 용량에 대한 메모리 할당을 할 수 없게된다. 

물리적으로 떨어진 빈 공간 여러 개를 프로세스가 하나의 영역으로 다루기에는 다음과 같은 문제점이 존재한다.

- 프로세스가 메모리를 획득할 때마다 메모리의 분할 개수를 확인해야 하므로 불편하다.

- 하나의 영역처럼 다루더라도 배열같이 연속된 데이터를 다루기가 쉽지 않다.

### 다른 프로세스의 메모리에 접근 가능

단순 메모리 할당 방식에서는 프로세스가 커널이나 다른 프로세스가 사용하고 있는 주소를 직접 지정할 경우 해당 영역에 접근할 수 있기 때문에 위험하다.

### 여러 프로세스 실행 시 문제

3장에서 readelf 명령어로 프로그램의 구조를 봤을 때, 코드와 데이터 영역의 파일 상 오프셋 등의 정보가 존재했다.

만약 동일한 프로그램으로 여러 프로세스를 생성하는 경우, 해당 메모리 영역들은 어쩔 수 없이 메모리 상에서 서로 다른 공간에 위치하게 된다. 이는 최대 1개의 프로세스만 프로그램의 정보에 있는 메모리 주소와 일치할 수 있으므로 다른 프로세스들은 실행할 수 없게된다.

만약 단순 메모리 할당 방식을 사용하면, 각 프로그램마다 동작할 주소가 겹치지 않도록 프로그래머가 신경써야 하는데, 현실적으로 불가능하다.

---

## 가상 메모리

위의 문제점들을 해결하기 위해 요즘 나오는 CPU에는 [메모리 관리 장치<sub>MMU, Memory Management Unit</sub>](https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B4%80%EB%A6%AC_%EC%9E%A5%EC%B9%98)가 존재하며, MMU에서 가상 메모리 주소를 실제 메모리 주소로 변환한다.

가상 메모리는 프로세스가 물리 메모리에 직접 접근(위에서 말한 단순 메모리 할당 방식)하지 않고, 가상 주소를 사용하여 간접적으로 접근하도록 하는 방식이다.

- 프로세스가 인식하는 주소는 가상 주소이고, 이를 CPU에서 변환하여 물리 주소에 접근한다.

- `readelf`, `cat /proc/PID/maps` 의 출력 결과에 나온 주소는 모두 가상 주소이다.

- **프로세스에서 물리 주소에 직접 접근하는 방법은 없다.**

### 페이지 테이블

가상 주소에서 물리 주소로의 변환은 커널 내부의 페이지 테이블<sub>Page Table</sub>을 참조한다. 변환은 페이지 단위로 이루어진다.

페이지 테이블에서 한 페이지에 대한 데이터를 페이지 테이블 엔트리<sub>PTE, Page Table Entry</sub>라고 한다.

- PTE에는 가상 주소와 물리 주소의 대응 정보가 들어있다.

- x86_64 아키텍처의 페이지 사이즈는 4KiB이다.

PT에 물리 주소가 매핑되지 않은 가상 주소에 접근하는 경우에는 CPU에 페이지 폴트<sub>page fault</sub> 인터럽트가 발생한다. 그러니까 PTE가 존재하지 않는 가상 주소에 접근한다는 것은 허용되지 않은 메모리 영역에 접근한다는 것이다.

- 현재 실행 중인 명령이 중단되고, 커널 내의 페이지 폴트 핸들러<sub>page fault handler</sub> 인터럽트 핸들러가 동작한다.

- 커널은 메모리 접근이 잘못되었다는 내용을 페이지 폴트 핸들러에 전달하고, SIGSEGV 시그널을 프로세스에 전달하여 프로세스를 강제 종료시킨다. C언어 프로그래밍할 때 많이 봤던 [segmentation fault](https://ko.wikipedia.org/wiki/%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98_%EC%98%A4%EB%A5%98)가 그 예시이다.

### segmentation fault 발생 프로그램

잘못된 주소에 접근하는 프로그램을 작성한다.

```sh
$ gcc -o output/segv src/segv.c 
$ output/segv
Before invalid access
[1]    9866 segmentation fault (core dumped)  output/segv
```

- `*p = 0;`을 처리하면서 segmentation fault가 발생한 것을 알 수 있다.

파이썬, javascript 등 메모리를 직접 다루지 않는 언어의 경우 직접 작성한 부분에서는 이런 에러가 발생하는 경우가 거의 없다.

---

## 메모리 할당 과정


